<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NVIDIA 2D Image And Signal Performance Primitives (NPP): NVIDIA 2D Image and Signal Processing Performance Primitives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVIDIA 2D Image And Signal Performance Primitives (NPP)
   &#160;<span id="projectnumber">Version 11.1.0.*</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NVIDIA 2D Image and Signal Processing Performance Primitives </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introduction_lb"></a>
What is NPP?</h1>
<p>NVIDIA NPP is a library of functions for performing CUDA accelerated 2D image and signal processing. The primary set of functionality in the library focuses on image processing and is widely applicable for developers in these areas. NPP will evolve over time to encompass more of the compute heavy tasks in a variety of problem domains. The NPP library is written to maximize flexibility, while maintaining high performance.</p>
<p>NPP can be used in one of two ways:</p>
<ul>
<li>A stand-alone library for adding GPU acceleration to an application with minimal effort. Using this route allows developers to add GPU acceleration to their applications in a matter of hours.</li>
<li>A cooperative library for interoperating with a developer's GPU code efficiently.</li>
</ul>
<p>Either route allows developers to harness the massive compute resources of NVIDIA GPUs, while simultaneously reducing development times. After reading this Main Page it is recommended that you read the General API Conventions page below and either the Image-Processing Specific API Conventions page or Signal-Processing Specific API Conventions page depending on the kind of processing you expect to do. Finally, if you select the Modules tab at the top of this page you can find the kinds of functions available for the NPP operations that support your needs.</p>
<h1><a class="anchor" id="documentaiton_lb"></a>
Documentation</h1>
<ul>
<li><a class="el" href="general_conventions_lb.html">General API Conventions</a></li>
<li><a class="el" href="nppi_conventions_lb.html">Image-Processing Specific API Conventions</a></li>
<li><a class="el" href="npps_conventions_lb.html">Signal-Processing Specific API Conventions</a></li>
</ul>
<h1><a class="anchor" id="Files"></a>
Files</h1>
<p>NPP API is defined in the following files:</p>
<h2><a class="anchor" id="header_files"></a>
Header Files</h2>
<ul>
<li><a class="el" href="npp_8h_source.html">npp.h</a></li>
<li><a class="el" href="nppdefs_8h_source.html">nppdefs.h</a></li>
<li><a class="el" href="nppcore_8h_source.html">nppcore.h</a></li>
<li><a class="el" href="nppi_8h_source.html">nppi.h</a></li>
<li><a class="el" href="npps_8h_source.html">npps.h</a></li>
</ul>
<p>All those header files are located in the following CUDA Toolkit's directory:</p>
<pre class="fragment">/include/ </pre><h2><a class="anchor" id="library_files"></a>
Library Files</h2>
<p>NPP's functionality is split up into 3 distinct library groups:</p>
<ul>
<li>A core library (NPPC) containing basic functionality from the <a class="el" href="npp_8h_source.html" title="Main include file for NPP library. ">npp.h</a> header file as well as common functionality used by the other two libraries.</li>
<li>The image processing library NPPI. Any functions from the <a class="el" href="nppi_8h_source.html" title="NPP Image Processing Functionality. ">nppi.h</a> header file or the various header files named "nppi_xxx.h" are bundled into the NPPI library.</li>
<li>The signal processing library NPPS. Any function from the <a class="el" href="npps_8h_source.html" title="NPP Signal Processing Functionality. ">npps.h</a> header file or the various header files named "npps_xxx.h" are bundled into the NPPS library.</li>
</ul>
<p>On the Windows platform the NPP stub libraries are found in the CUDA Toolkit's library directory: </p>
<pre class="fragment">/lib/nppc.lib </pre> <pre class="fragment">/lib/nppial.lib </pre> <pre class="fragment">/lib/nppicc.lib </pre> <pre class="fragment">/lib/nppidei.lib </pre> <pre class="fragment">/lib/nppif.lib </pre> <pre class="fragment">/lib/nppig.lib </pre> <pre class="fragment">/lib/nppim.lib </pre> <pre class="fragment">/lib/nppist.lib </pre> <pre class="fragment">/lib/nppisu.lib </pre> <pre class="fragment">/lib/nppitc.lib </pre> <pre class="fragment">/lib/npps.lib </pre><p>The matching DLLs are located in the CUDA Toolkit's binary directory. Example </p>
<pre class="fragment">* /bin/nppial64_111_&lt;build_no&gt;.dll  // Dynamic image-processing library for 64-bit Windows.</pre><p>On Linux platforms the dynamic libraries are located in the lib directory and the names include major and minor version numbers along with build numbers </p>
<pre class="fragment">* /lib/libnppc.so.11.1.&lt;build_no&gt;   // NPP dynamic core library for Linux</pre><h1><a class="anchor" id="NPP"></a>
Library Organization</h1>
<p>Note: The static NPP libraries depend on a common thread abstraction layer library called cuLIBOS (<code>libculibos.a</code>) that is now distributed as a part of the toolkit. Consequently, cuLIBOS must be provided to the linker when the static library is being linked against. To minimize library loading and CUDA runtime startup times it is recommended to use the static library(s) whenever possible. To improve loading and runtime performance when using dynamic libraries, NPP provides a full set of NPPI sub-libraries. Linking to only the sub-libraries that contain functions that your application uses can significantly improve load time and runtime startup performance. Some NPPI functions make calls to other NPPI and/or NPPS functions internally so you may need to link to a few extra libraries depending on what function calls your application makes. The NPPI sub-libraries are split into sections corresponding to the way that NPPI header files are split. This list of sub-libraries is as follows:</p>
<ul>
<li>NPPC, NPP core library which MUST be included when linking any application, functions are listed in <a class="el" href="nppcore_8h_source.html" title="Basic NPP functionality. ">nppCore.h</a>,</li>
<li>NPPIAL, arithmetic and logical operation functions in <a class="el" href="nppi__arithmetic__and__logical__operations_8h_source.html" title="Image Arithmetic and Logical Operations. ">nppi_arithmetic_and_logical_operations.h</a>,</li>
<li>NPPICC, color conversion and sampling functions in <a class="el" href="nppi__color__conversion_8h_source.html" title="NPP Image Processing Functionality. ">nppi_color_conversion.h</a>,</li>
<li>NPPIDEI, data exchange and initialization functions in <a class="el" href="nppi__data__exchange__and__initialization_8h_source.html" title="NPP Image Processing Functionality. ">nppi_data_exchange_and_initialization.h</a>,</li>
<li>NPPIF, filtering and computer vision functions in <a class="el" href="nppi__filtering__functions_8h_source.html" title="NPP Image Processing Functionality. ">nppi_filtering_functions.h</a>,</li>
<li>NPPIG, geometry transformation functions found in <a class="el" href="nppi__geometry__transforms_8h_source.html" title="Image Geometry Transform Primitives. ">nppi_geometry_transforms.h</a>,</li>
<li>NPPIM, morphological operation functions found in <a class="el" href="nppi__morphological__operations_8h_source.html" title="NPP Image Processing Functionality. ">nppi_morphological_operations.h</a>,</li>
<li>NPPIST, statistics and linear transform in <a class="el" href="nppi__statistics__functions_8h_source.html" title="NPP Image Processing Functionality. ">nppi_statistics_functions.h</a> and <a class="el" href="nppi__linear__transforms_8h_source.html" title="NPP Image Processing Functionality. ">nppi_linear_transforms.h</a>,</li>
<li>NPPISU, memory support functions in <a class="el" href="nppi__support__functions_8h_source.html" title="NPP Image Processing Functionality. ">nppi_support_functions.h</a>,</li>
<li>NPPITC, threshold and compare operation functions in <a class="el" href="nppi__threshold__and__compare__operations_8h_source.html" title="NPP Image Processing Functionality. ">nppi_threshold_and_compare_operations.h</a>,</li>
</ul>
<p>For example, on Linux, to compile a small color conversion application <code>foo</code> using NPP against the dynamic library, the following command can be used: </p>
<div class="fragment"><div class="line">*        nvcc foo.c  -lnppc -lnppicc -o foo</div>
</div><!-- fragment --><p>Whereas to compile against the static NPP library, the following command has to be used: </p>
<div class="fragment"><div class="line">*        nvcc foo.c  -lnppc_static -lnppicc_static -lculibos -o foo</div>
</div><!-- fragment --><p>It is also possible to use the native host C++ compiler. Depending on the host operating system, some additional libraries like pthread or dl might be needed on the linking line. The following command on Linux is suggested: </p>
<div class="fragment"><div class="line">*        g++ foo.c  -lnppc_static -lnppicc_static -lculibos -lcudart_static -lpthread -ldl </div>
<div class="line">*        -I &lt;cuda-toolkit-path&gt;/include -L &lt;cuda-toolkit-path&gt;/lib64 -o foo</div>
</div><!-- fragment --><p>NPP is a stateless API, as of NPP 6.5 the ONLY state that NPP remembers between function calls is the current stream ID, i.e. the stream ID that was set in the most recent <a class="el" href="group__core__npp.html#ga155122a2138b944949b0920e2bb1120f" title="Set the NPP CUDA stream. ">nppSetStream()</a> call and a few bits of device specific information about that stream. The default stream ID is 0. If an application intends to use NPP with multiple streams then it is the responsibility of the application to use the fully stateless application managed stream context interface described below or call <a class="el" href="group__core__npp.html#ga155122a2138b944949b0920e2bb1120f" title="Set the NPP CUDA stream. ">nppSetStream()</a> whenever it wishes to change stream IDs. Any NPP function call which does not use an application managed stream context will use the stream set by the most recent call to <a class="el" href="group__core__npp.html#ga155122a2138b944949b0920e2bb1120f" title="Set the NPP CUDA stream. ">nppSetStream()</a> and <a class="el" href="group__core__npp.html#ga7b5dd1c9dc541b35137b0635e3150c07" title="Get the NPP CUDA stream. ">nppGetStream()</a> and other "nppGet" type function calls which do not contain an application managed stream context parameter will also always use that stream.</p>
<p>All NPP functions should be thread safe.</p>
<p>Note: New to NPP 10.1 is support for the fp16 (__half) data type in GPU architectures of Volta and beyond in some NPP image processing functions. NPP image functions that support pixels of __half data types have function names of type 16f and pointers to pixels of that data type need to be passed to NPP as NPP data type <a class="el" href="struct_npp16f.html">Npp16f</a>. Here is an example of how to pass image pointers of type __half to an NPP 16f function that should work on all compilers including Armv7.</p>
<div class="fragment"><div class="line">*        <a class="code" href="group__image__add.html#gaee03970b8d40ceb3d3670a7d6e6bdb1a">nppiAdd_16f_C3R</a>(reinterpret_cast&lt;const Npp16f *&gt;((<span class="keyword">const</span> <span class="keywordtype">void</span> *)(pSrc1Data)), nSrc1Pitch,</div>
<div class="line">*                        reinterpret_cast&lt;const Npp16f *&gt;((<span class="keyword">const</span> <span class="keywordtype">void</span> *)(pSrc2Data)), nSrc2Pitch,</div>
<div class="line">*                        reinterpret_cast&lt;Npp16f *&gt;((<span class="keywordtype">void</span> *)(pDstData)),  nDstPitch,</div>
<div class="line">*                        oDstROI);</div>
</div><!-- fragment --><h1><a class="anchor" id="application_managed_stream_context"></a>
Application Managed Stream Context</h1>
<p>Note: Also new to NPP 10.1 is support for application managed stream contexts. Application managed stream contexts make NPP truely stateless internally allowing for rapid, no overhead, stream context switching. While it is recommended that all new NPP application code use application managed stream contexts, existing application code can continue to use <a class="el" href="group__core__npp.html#ga155122a2138b944949b0920e2bb1120f" title="Set the NPP CUDA stream. ">nppSetStream()</a> and <a class="el" href="group__core__npp.html#ga7b5dd1c9dc541b35137b0635e3150c07" title="Get the NPP CUDA stream. ">nppGetStream()</a> to manage stream contexts (also with no overhead now) but over time NPP will likely deprecate the older non-application managed stream context API. Both the new and old stream management techniques can be intermixed in applications but any NPP calls using the old API will use the stream set by the most recent call to <a class="el" href="group__core__npp.html#ga155122a2138b944949b0920e2bb1120f" title="Set the NPP CUDA stream. ">nppSetStream()</a> and <a class="el" href="group__core__npp.html#ga7b5dd1c9dc541b35137b0635e3150c07" title="Get the NPP CUDA stream. ">nppGetStream()</a> calls will also return that stream ID. All NPP function names ending in _Ctx expect application managed stream contexts to be passed as a parameter to that function. The new <a class="el" href="struct_npp_stream_context.html" title="NPP stream context structure must be filled in by application. ">NppStreamContext</a> application managed stream context structure is defined in <a class="el" href="nppdefs_8h_source.html" title="Typedefinitions and macros for NPP library. ">nppdefs.h</a> and should be initialized by the application to the Cuda device ID and values associated with a particular stream. Applications can use multiple fixed stream contexts or change the values in a particular stream context on the fly whenever a different stream is to be used.</p>
<p>Note: NPP 10.2 and beyond contain an additional element in the <a class="el" href="struct_npp_stream_context.html" title="NPP stream context structure must be filled in by application. ">NppStreamContext</a> structure named nStreamFlags which MUST also be initialized by the application. Failure to do so could unnecessarily reduce NPP performance in some functions.</p>
<p>Note: NPP does not support non blocking streams on Windows for devices working in WDDM mode.</p>
<p>Note that some of the "GetBufferSize" style functions now have application managed stream contexts associated with them and should be used with the same stream context that the associated application managed stream context NPP function will use.</p>
<p>Note that NPP does minimal checking of the parameters in an application managed stream context structure so it is up to the application to assure that they are correct and valid when passed to NPP functions.</p>
<p>Note that NPP has deprecated the nppicom JPEG compression library as of NPP 11.0, use the NVJPEG library instead.</p>
<h1><a class="anchor" id="supported_hardware"></a>
Supported NVIDIA Hardware</h1>
<p>NPP runs on all CUDA capable NVIDIA hardware. For details please see <a href="http://www.nvidia.com/object/cuda_learn_products.html">http://www.nvidia.com/object/cuda_learn_products.html</a> </p>
</div></div><!-- contents -->
<HR>
<center>Copyright &copy; 2009-2020 NVIDIA Corporation</center>
<HR>