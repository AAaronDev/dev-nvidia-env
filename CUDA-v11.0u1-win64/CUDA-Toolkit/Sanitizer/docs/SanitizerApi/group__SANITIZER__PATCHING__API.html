<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SanitizerApi: Sanitizer Patching API</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Sanitizer Patching API</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g4b7e57672cf60e7ae4ac55176d2ab834">SanitizerCallbackBarrier</a> )(void *userdata, uint64_t pc, uint32_t barIndex, uint32_t threadCount, uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a barrier callback.  <a href="#g4b7e57672cf60e7ae4ac55176d2ab834"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g4aab2ddf5dc879434f2201c1f4da15cb">SanitizerCallbackBlockEnter</a> )(void *userdata, uint64_t pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a CUDA block enter callback.  <a href="#g4aab2ddf5dc879434f2201c1f4da15cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g6d29c0ef356ff8cf83528d6089890e1a">SanitizerCallbackBlockExit</a> )(void *userdata, uint64_t pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a CUDA block exit callback.  <a href="#g6d29c0ef356ff8cf83528d6089890e1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g232756bcf8464f0f4807345b3c87ce81">SanitizerCallbackCall</a> )(void *userdata, uint64_t pc, uint64_t targetPc, uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a function call callback.  <a href="#g232756bcf8464f0f4807345b3c87ce81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g353c3b8eac7e039c38ddc14d730fc495">SanitizerCallbackDeviceSideFree</a> )(void *userdata, uint64_t pc, void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a device-side free call.  <a href="#g353c3b8eac7e039c38ddc14d730fc495"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g4d2f17557934af858ce29328fed19e3f">SanitizerCallbackDeviceSideMalloc</a> )(void *userdata, uint64_t pc, void *allocatedPtr, uint64_t allocatedSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a device-side malloc call.  <a href="#g4d2f17557934af858ce29328fed19e3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#gbd264aa7fdf8c45f12b58b82d1d981aa">SanitizerCallbackMemoryAccess</a> )(void *userdata, uint64_t pc, void *ptr, uint32_t accessSize, uint32_t flags, const void *newValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a memory access callback.  <a href="#gbd264aa7fdf8c45f12b58b82d1d981aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#gd18d7759b00b28bbbbfb5279261c8cc9">SanitizerCallbackRet</a> )(void *userdata, uint64_t pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a function return callback.  <a href="#gd18d7759b00b28bbbbfb5279261c8cc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g7d14e7f12b6f9fd9c5f1f5324b3e9c58">SanitizerCallbackShfl</a> )(void *userdata, uint64_t pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a shfl callback.  <a href="#g7d14e7f12b6f9fd9c5f1f5324b3e9c58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#gba999e65bfd8fc65771f12a98b6d6de3">SanitizerCallbackSyncwarp</a> )(void *userdata, uint64_t pc, uint32_t mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function type for a syncwarp callback.  <a href="#gba999e65bfd8fc65771f12a98b6d6de3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g22dc34eb2f89b61aa2a8535c8c089209">Sanitizer_BarrierFlags</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg22dc34eb2f89b61aa2a8535c8c0892096af1eab444b00487919dff702c88bbd7">SANITIZER_BARRIER_FLAG_NONE</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg22dc34eb2f89b61aa2a8535c8c0892092cf84ebfb48dc201dda3333237e78c22">SANITIZER_BARRIER_FLAG_UNALIGNED_ALLOWED</a> =  0x1
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags describing a barrier.  <a href="group__SANITIZER__PATCHING__API.html#g22dc34eb2f89b61aa2a8535c8c089209">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g2c82c2446853ee79b55d71b098181ca1">Sanitizer_CallFlags</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg2c82c2446853ee79b55d71b098181ca13cf48edeb09a68cb3c0920a21dd09d7b">SANITIZER_CALL_FLAG_NONE</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg2c82c2446853ee79b55d71b098181ca1208e029b1ae7767951345e14e60b1c1b">SANITIZER_CALL_FLAG_UNALIGNED_ALLOWED</a> =  0x1
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags describing a function call.  <a href="group__SANITIZER__PATCHING__API.html#g2c82c2446853ee79b55d71b098181ca1">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#ga177905ebbb1a243f0784662d6de9c0e">Sanitizer_DeviceMemoryFlags</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0ebe87dde2e3c4474d7c0e3525483ad08c">SANITIZER_MEMORY_DEVICE_FLAG_NONE</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0e22aa86808c07a6e8243d376e6f972023">SANITIZER_MEMORY_DEVICE_FLAG_READ</a> =  0x1, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0ea9fcb4800449066a51276f33394b03fe">SANITIZER_MEMORY_DEVICE_FLAG_WRITE</a> =  0x2, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0ed90430be7f917f6706600b4f27575a79">SANITIZER_MEMORY_DEVICE_FLAG_ATOMSYS</a> =  0x4, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0e692f5ce53b384b0362bc82036720ed95">SANITIZER_MEMORY_DEVICE_FLAG_LOCAL</a> =  0x8, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gga177905ebbb1a243f0784662d6de9c0efe729a26414921c1d11fe74c2a9fb35b">SANITIZER_MEMORY_DEVICE_FLAG_SHARED</a> =  0x10
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags describing a memory access.  <a href="group__SANITIZER__PATCHING__API.html#ga177905ebbb1a243f0784662d6de9c0e">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g25af2e64f4c5e2a4e012edb4bb991dcf">Sanitizer_InstructionId</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcfb792b56a62fc2cab8ce6f05827bee57e">SANITIZER_INSTRUCTION_INVALID</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcf7c59f819d654294b1d03556920b6506a">SANITIZER_INSTRUCTION_BLOCK_ENTER</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcfab863a91dcec4dba6d646493730c6dba">SANITIZER_INSTRUCTION_BLOCK_EXIT</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcfe11bf44c27bbe4d3cb560b039c90998c">SANITIZER_INSTRUCTION_MEMORY_ACCESS</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcfc1de637e650a2ffe7873d9773dfe81dd">SANITIZER_INSTRUCTION_BARRIER</a> =  4, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcf675ff6968f4b589338b73ca52ff5e51d">SANITIZER_INSTRUCTION_SYNCWARP</a> =  5, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcff7dfa1d13d455871e8cf277e96fa98e0">SANITIZER_INSTRUCTION_SHFL</a> =  6, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcfe794dd6b50d2cc90f31cadaf82c83183">SANITIZER_INSTRUCTION_CALL</a> =  7, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcf6ffff69ff42f32340d6c1629600fdf68">SANITIZER_INSTRUCTION_RET</a> =  8, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcf1d5cb2a1144869418634b105ffea08ce">SANITIZER_INSTRUCTION_DEVICE_SIDE_MALLOC</a> =  9, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg25af2e64f4c5e2a4e012edb4bb991dcf55e73a8a1fdf8f213e67c9e8d776782c">SANITIZER_INSTRUCTION_DEVICE_SIDE_FREE</a> =  10
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instrumentation.  <a href="group__SANITIZER__PATCHING__API.html#g25af2e64f4c5e2a4e012edb4bb991dcf">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg3db35bcf534fa726680c73ba242b2e70b27e6d43015f3cf83c222664f5252b0f">SANITIZER_PATCH_SUCCESS</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg3db35bcf534fa726680c73ba242b2e70f061ff3eeec7622c42c45bdb2ef6a9fc">SANITIZER_PATCH_INVALID_MEMORY_ACCESS</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="group__SANITIZER__PATCHING__API.html#gg3db35bcf534fa726680c73ba242b2e70957233c4b5cc044cae5efcc7c29dec06">SANITIZER_PATCH_INVALID_SYNCHRONIZATION</a> =  2
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sanitizer patch result codes.  <a href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g9d63f4e3663fc4ce4558668afc151a39">sanitizerAddPatches</a> (const void *image, CUcontext ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a module containing patches that can be used by the patching API.  <a href="#g9d63f4e3663fc4ce4558668afc151a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g04ea679ab0708224d366c48e651e40ef">sanitizerAddPatchesFromFile</a> (const char *filename, CUcontext ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a module containing patches that can be used by the patching API.  <a href="#g04ea679ab0708224d366c48e651e40ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g8a243dfc09dc2f676114409039a3e80d">sanitizerGetCallbackPcAndSize</a> (CUcontext ctx, const char *deviceCallbackName, uint64_t *pc, uint64_t *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get PC and size of a device callback.  <a href="#g8a243dfc09dc2f676114409039a3e80d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g505e9ee66db67d02d15c47b874859545">sanitizerGetFunctionPcAndSize</a> (CUmodule module, const char *functionName, uint64_t *pc, uint64_t *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get PC and size of a CUDA function.  <a href="#g505e9ee66db67d02d15c47b874859545"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g4047e8742dc65935c2ab45d19a53b850">sanitizerPatchInstructions</a> (const <a class="el" href="group__SANITIZER__PATCHING__API.html#g25af2e64f4c5e2a4e012edb4bb991dcf">Sanitizer_InstructionId</a> instructionId, CUmodule module, const char *deviceCallbackName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set instrumentation points and patches to be applied in a module.  <a href="#g4047e8742dc65935c2ab45d19a53b850"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> (CUmodule module)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform the actual instrumentation of a module.  <a href="#g2e7500a0e365b2ddf6c273c87a34b22d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g55712541951d15f51e8c294382f91be0">sanitizerSetCallbackData</a> (CUfunction kernel, const void *userdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the user data pointer for callbacks.  <a href="#g55712541951d15f51e8c294382f91be0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__PATCHING__API.html#g5ac4eb8e7b484ac3e70c459413791b22">sanitizerUnpatchModule</a> (CUmodule module)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove existing instrumentation of a module.  <a href="#g5ac4eb8e7b484ac3e70c459413791b22"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions, types, and enums that implement the Sanitizer Patching API. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g4b7e57672cf60e7ae4ac55176d2ab834"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackBarrier" ref="g4b7e57672cf60e7ae4ac55176d2ab834" args=")(void *userdata, uint64_t pc, uint32_t barIndex, uint32_t threadCount, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g4b7e57672cf60e7ae4ac55176d2ab834">SanitizerCallbackBarrier</a>)(void *userdata, uint64_t pc, uint32_t barIndex, uint32_t threadCount, uint32_t flags)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>barIndex</code> is the barrier index. <code>threadCount</code> is the number of expected threads (must be a multiple of the warp size). <code>flags</code> contains information about the barrier. See Sanitizer_BarrierFlags to interpret this value. 0 means that all threads are participating in the barrier. 
</div>
</div><p>
<a class="anchor" name="g4aab2ddf5dc879434f2201c1f4da15cb"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackBlockEnter" ref="g4aab2ddf5dc879434f2201c1f4da15cb" args=")(void *userdata, uint64_t pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g4aab2ddf5dc879434f2201c1f4da15cb">SanitizerCallbackBlockEnter</a>)(void *userdata, uint64_t pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the entry point of the block 
</div>
</div><p>
<a class="anchor" name="g6d29c0ef356ff8cf83528d6089890e1a"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackBlockExit" ref="g6d29c0ef356ff8cf83528d6089890e1a" args=")(void *userdata, uint64_t pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g6d29c0ef356ff8cf83528d6089890e1a">SanitizerCallbackBlockExit</a>)(void *userdata, uint64_t pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction 
</div>
</div><p>
<a class="anchor" name="g232756bcf8464f0f4807345b3c87ce81"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackCall" ref="g232756bcf8464f0f4807345b3c87ce81" args=")(void *userdata, uint64_t pc, uint64_t targetPc, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g232756bcf8464f0f4807345b3c87ce81">SanitizerCallbackCall</a>)(void *userdata, uint64_t pc, uint64_t targetPc, uint32_t flags)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>targetPc</code> is the PC where the called function is located. <code>flags</code> contains information about the function call. 
</div>
</div><p>
<a class="anchor" name="g353c3b8eac7e039c38ddc14d730fc495"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackDeviceSideFree" ref="g353c3b8eac7e039c38ddc14d730fc495" args=")(void *userdata, uint64_t pc, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g353c3b8eac7e039c38ddc14d730fc495">SanitizerCallbackDeviceSideFree</a>)(void *userdata, uint64_t pc, void *ptr)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is called prior to the actual call.</dd></dl>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>ptr</code> is the pointer passed to device-side free. 
</div>
</div><p>
<a class="anchor" name="g4d2f17557934af858ce29328fed19e3f"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackDeviceSideMalloc" ref="g4d2f17557934af858ce29328fed19e3f" args=")(void *userdata, uint64_t pc, void *allocatedPtr, uint64_t allocatedSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g4d2f17557934af858ce29328fed19e3f">SanitizerCallbackDeviceSideMalloc</a>)(void *userdata, uint64_t pc, void *allocatedPtr, uint64_t allocatedSize)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is called after the call has completed.</dd></dl>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>allocatedPtr</code> is the pointer returned by device-side malloc <code>allocatedSize</code> is the size requested by the user to device-side malloc. 
</div>
</div><p>
<a class="anchor" name="gbd264aa7fdf8c45f12b58b82d1d981aa"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackMemoryAccess" ref="gbd264aa7fdf8c45f12b58b82d1d981aa" args=")(void *userdata, uint64_t pc, void *ptr, uint32_t accessSize, uint32_t flags, const void *newValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#gbd264aa7fdf8c45f12b58b82d1d981aa">SanitizerCallbackMemoryAccess</a>)(void *userdata, uint64_t pc, void *ptr, uint32_t accessSize, uint32_t flags, const void *newValue)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>ptr</code> is the address of the memory being accessed. For local or shared memory access, this is the offset within the local or shared memory window. <code>accessSize</code> is the size of the access in bytes. Valid values are 1, 2, 4, 8, and 16. <code>flags</code> contains information about the type of access. See Sanitizer_DeviceMemoryFlags to interpret this value. <code>newValue</code> is a pointer to the new value being written if the acces is a write. If the access is a read or an atomic, the pointer will be NULL. 
</div>
</div><p>
<a class="anchor" name="gd18d7759b00b28bbbbfb5279261c8cc9"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackRet" ref="gd18d7759b00b28bbbbfb5279261c8cc9" args=")(void *userdata, uint64_t pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#gd18d7759b00b28bbbbfb5279261c8cc9">SanitizerCallbackRet</a>)(void *userdata, uint64_t pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction 
</div>
</div><p>
<a class="anchor" name="g7d14e7f12b6f9fd9c5f1f5324b3e9c58"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackShfl" ref="g7d14e7f12b6f9fd9c5f1f5324b3e9c58" args=")(void *userdata, uint64_t pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#g7d14e7f12b6f9fd9c5f1f5324b3e9c58">SanitizerCallbackShfl</a>)(void *userdata, uint64_t pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction 
</div>
</div><p>
<a class="anchor" name="gba999e65bfd8fc65771f12a98b6d6de3"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerCallbackSyncwarp" ref="gba999e65bfd8fc65771f12a98b6d6de3" args=")(void *userdata, uint64_t pc, uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>(SANITIZERAPI * <a class="el" href="group__SANITIZER__PATCHING__API.html#gba999e65bfd8fc65771f12a98b6d6de3">SanitizerCallbackSyncwarp</a>)(void *userdata, uint64_t pc, uint32_t mask)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>userdata</code> is a pointer to user data. See <a class="el" href="group__SANITIZER__PATCHING__API.html#g2e7500a0e365b2ddf6c273c87a34b22d">sanitizerPatchModule</a> <code>pc</code> is the program counter of the patched instruction <code>mask</code> is the thread mask passed to __syncwarp(). 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g22dc34eb2f89b61aa2a8535c8c089209"></a><!-- doxytag: member="sanitizer_patching.h::Sanitizer_BarrierFlags" ref="g22dc34eb2f89b61aa2a8535c8c089209" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SANITIZER__PATCHING__API.html#g22dc34eb2f89b61aa2a8535c8c089209">Sanitizer_BarrierFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags describing a barrier. These values are to be or-combined in the value of <b>flags</b> for a SanitizerCallbackBarrier callback. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg22dc34eb2f89b61aa2a8535c8c0892096af1eab444b00487919dff702c88bbd7"></a><!-- doxytag: member="SANITIZER_BARRIER_FLAG_NONE" ref="gg22dc34eb2f89b61aa2a8535c8c0892096af1eab444b00487919dff702c88bbd7" args="" -->SANITIZER_BARRIER_FLAG_NONE</em>&nbsp;</td><td>
Empty flag. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg22dc34eb2f89b61aa2a8535c8c0892092cf84ebfb48dc201dda3333237e78c22"></a><!-- doxytag: member="SANITIZER_BARRIER_FLAG_UNALIGNED_ALLOWED" ref="gg22dc34eb2f89b61aa2a8535c8c0892092cf84ebfb48dc201dda3333237e78c22" args="" -->SANITIZER_BARRIER_FLAG_UNALIGNED_ALLOWED</em>&nbsp;</td><td>
Specifies that the barrier can be called unaligned. This flag is only valid on SM 7.0 and above. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2c82c2446853ee79b55d71b098181ca1"></a><!-- doxytag: member="sanitizer_patching.h::Sanitizer_CallFlags" ref="g2c82c2446853ee79b55d71b098181ca1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SANITIZER__PATCHING__API.html#g2c82c2446853ee79b55d71b098181ca1">Sanitizer_CallFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags describing a function call. These values are to be or-combined in the value of <b>flags</b> for a SanitizerCallbackCall callback. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg2c82c2446853ee79b55d71b098181ca13cf48edeb09a68cb3c0920a21dd09d7b"></a><!-- doxytag: member="SANITIZER_CALL_FLAG_NONE" ref="gg2c82c2446853ee79b55d71b098181ca13cf48edeb09a68cb3c0920a21dd09d7b" args="" -->SANITIZER_CALL_FLAG_NONE</em>&nbsp;</td><td>
Empty flag. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg2c82c2446853ee79b55d71b098181ca1208e029b1ae7767951345e14e60b1c1b"></a><!-- doxytag: member="SANITIZER_CALL_FLAG_UNALIGNED_ALLOWED" ref="gg2c82c2446853ee79b55d71b098181ca1208e029b1ae7767951345e14e60b1c1b" args="" -->SANITIZER_CALL_FLAG_UNALIGNED_ALLOWED</em>&nbsp;</td><td>
Specifies that barriers within this function call can be called unaligned. This flag is only valid on SM 7.0 and above. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga177905ebbb1a243f0784662d6de9c0e"></a><!-- doxytag: member="sanitizer_patching.h::Sanitizer_DeviceMemoryFlags" ref="ga177905ebbb1a243f0784662d6de9c0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SANITIZER__PATCHING__API.html#ga177905ebbb1a243f0784662d6de9c0e">Sanitizer_DeviceMemoryFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags describing a memory access. These values are to be or-combined in the value of <b>flags</b> for a SanitizerCallbackMemoryAccess callback.<p>
If neither LOCAL or SHARED flag is set, the access is made to global memory. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0ebe87dde2e3c4474d7c0e3525483ad08c"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_NONE" ref="gga177905ebbb1a243f0784662d6de9c0ebe87dde2e3c4474d7c0e3525483ad08c" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_NONE</em>&nbsp;</td><td>
Empty flag. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0e22aa86808c07a6e8243d376e6f972023"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_READ" ref="gga177905ebbb1a243f0784662d6de9c0e22aa86808c07a6e8243d376e6f972023" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_READ</em>&nbsp;</td><td>
Specifies that the access is a read. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0ea9fcb4800449066a51276f33394b03fe"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_WRITE" ref="gga177905ebbb1a243f0784662d6de9c0ea9fcb4800449066a51276f33394b03fe" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_WRITE</em>&nbsp;</td><td>
Specifies that the access is a write. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0ed90430be7f917f6706600b4f27575a79"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_ATOMSYS" ref="gga177905ebbb1a243f0784662d6de9c0ed90430be7f917f6706600b4f27575a79" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_ATOMSYS</em>&nbsp;</td><td>
Specifies that the access is a system-scoped atomic. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0e692f5ce53b384b0362bc82036720ed95"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_LOCAL" ref="gga177905ebbb1a243f0784662d6de9c0e692f5ce53b384b0362bc82036720ed95" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_LOCAL</em>&nbsp;</td><td>
Specifies that the memory accessed is local memory. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga177905ebbb1a243f0784662d6de9c0efe729a26414921c1d11fe74c2a9fb35b"></a><!-- doxytag: member="SANITIZER_MEMORY_DEVICE_FLAG_SHARED" ref="gga177905ebbb1a243f0784662d6de9c0efe729a26414921c1d11fe74c2a9fb35b" args="" -->SANITIZER_MEMORY_DEVICE_FLAG_SHARED</em>&nbsp;</td><td>
Specifies that the memory accessed is shared memory. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g25af2e64f4c5e2a4e012edb4bb991dcf"></a><!-- doxytag: member="sanitizer_patching.h::Sanitizer_InstructionId" ref="g25af2e64f4c5e2a4e012edb4bb991dcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SANITIZER__PATCHING__API.html#g25af2e64f4c5e2a4e012edb4bb991dcf">Sanitizer_InstructionId</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instrumentation. Every entry represent an instruction type or a function call where a callback patch can be inserted. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcfb792b56a62fc2cab8ce6f05827bee57e"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_INVALID" ref="gg25af2e64f4c5e2a4e012edb4bb991dcfb792b56a62fc2cab8ce6f05827bee57e" args="" -->SANITIZER_INSTRUCTION_INVALID</em>&nbsp;</td><td>
Invalid instruction ID. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcf7c59f819d654294b1d03556920b6506a"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_BLOCK_ENTER" ref="gg25af2e64f4c5e2a4e012edb4bb991dcf7c59f819d654294b1d03556920b6506a" args="" -->SANITIZER_INSTRUCTION_BLOCK_ENTER</em>&nbsp;</td><td>
CUDA block enter. This is called prior to any user code. The type of the callback must be SanitizerCallbackBlockEnter. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcfab863a91dcec4dba6d646493730c6dba"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_BLOCK_EXIT" ref="gg25af2e64f4c5e2a4e012edb4bb991dcfab863a91dcec4dba6d646493730c6dba" args="" -->SANITIZER_INSTRUCTION_BLOCK_EXIT</em>&nbsp;</td><td>
CUDA block exit. This is called after all user code has executed. The type of the callback must be SanitizerCallbackBlockExit. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcfe11bf44c27bbe4d3cb560b039c90998c"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_MEMORY_ACCESS" ref="gg25af2e64f4c5e2a4e012edb4bb991dcfe11bf44c27bbe4d3cb560b039c90998c" args="" -->SANITIZER_INSTRUCTION_MEMORY_ACCESS</em>&nbsp;</td><td>
Memory Access. This can be a store, load or atomic operation. The type of the callback must be SanitizerCallbackMemoryAccess. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcfc1de637e650a2ffe7873d9773dfe81dd"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_BARRIER" ref="gg25af2e64f4c5e2a4e012edb4bb991dcfc1de637e650a2ffe7873d9773dfe81dd" args="" -->SANITIZER_INSTRUCTION_BARRIER</em>&nbsp;</td><td>
Barrier. The type of the callback must be SanitizerCallbackBarrier. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcf675ff6968f4b589338b73ca52ff5e51d"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_SYNCWARP" ref="gg25af2e64f4c5e2a4e012edb4bb991dcf675ff6968f4b589338b73ca52ff5e51d" args="" -->SANITIZER_INSTRUCTION_SYNCWARP</em>&nbsp;</td><td>
Syncwarp. The type of the callback must be SanitizerCallbackSyncwarp. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcff7dfa1d13d455871e8cf277e96fa98e0"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_SHFL" ref="gg25af2e64f4c5e2a4e012edb4bb991dcff7dfa1d13d455871e8cf277e96fa98e0" args="" -->SANITIZER_INSTRUCTION_SHFL</em>&nbsp;</td><td>
Shfl. The type of the callback must be SanitizerCallbackShfl. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcfe794dd6b50d2cc90f31cadaf82c83183"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_CALL" ref="gg25af2e64f4c5e2a4e012edb4bb991dcfe794dd6b50d2cc90f31cadaf82c83183" args="" -->SANITIZER_INSTRUCTION_CALL</em>&nbsp;</td><td>
Function call. The type of the callback must be SanitizerCallbackCall. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcf6ffff69ff42f32340d6c1629600fdf68"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_RET" ref="gg25af2e64f4c5e2a4e012edb4bb991dcf6ffff69ff42f32340d6c1629600fdf68" args="" -->SANITIZER_INSTRUCTION_RET</em>&nbsp;</td><td>
Function return. The type of the callback must be SanitizerCallbackRet. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcf1d5cb2a1144869418634b105ffea08ce"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_DEVICE_SIDE_MALLOC" ref="gg25af2e64f4c5e2a4e012edb4bb991dcf1d5cb2a1144869418634b105ffea08ce" args="" -->SANITIZER_INSTRUCTION_DEVICE_SIDE_MALLOC</em>&nbsp;</td><td>
Device-side malloc. The type of the callback must be SanitizerCallbackDeviceSideMalloc. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg25af2e64f4c5e2a4e012edb4bb991dcf55e73a8a1fdf8f213e67c9e8d776782c"></a><!-- doxytag: member="SANITIZER_INSTRUCTION_DEVICE_SIDE_FREE" ref="gg25af2e64f4c5e2a4e012edb4bb991dcf55e73a8a1fdf8f213e67c9e8d776782c" args="" -->SANITIZER_INSTRUCTION_DEVICE_SIDE_FREE</em>&nbsp;</td><td>
Device-side free. The type of the callback must be SanitizerCallbackDeviceSideFree. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3db35bcf534fa726680c73ba242b2e70"></a><!-- doxytag: member="sanitizer_patching.h::SanitizerPatchResult" ref="g3db35bcf534fa726680c73ba242b2e70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SANITIZER__PATCHING__API.html#g3db35bcf534fa726680c73ba242b2e70">SanitizerPatchResult</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Error and result codes returned by Sanitizer patches. If a patch returns with an error code different than SANITIZER_PATCH_SUCCESS, the thread will be exited. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg3db35bcf534fa726680c73ba242b2e70b27e6d43015f3cf83c222664f5252b0f"></a><!-- doxytag: member="SANITIZER_PATCH_SUCCESS" ref="gg3db35bcf534fa726680c73ba242b2e70b27e6d43015f3cf83c222664f5252b0f" args="" -->SANITIZER_PATCH_SUCCESS</em>&nbsp;</td><td>
No error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3db35bcf534fa726680c73ba242b2e70f061ff3eeec7622c42c45bdb2ef6a9fc"></a><!-- doxytag: member="SANITIZER_PATCH_INVALID_MEMORY_ACCESS" ref="gg3db35bcf534fa726680c73ba242b2e70f061ff3eeec7622c42c45bdb2ef6a9fc" args="" -->SANITIZER_PATCH_INVALID_MEMORY_ACCESS</em>&nbsp;</td><td>
An invalid memory access was performed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3db35bcf534fa726680c73ba242b2e70957233c4b5cc044cae5efcc7c29dec06"></a><!-- doxytag: member="SANITIZER_PATCH_INVALID_SYNCHRONIZATION" ref="gg3db35bcf534fa726680c73ba242b2e70957233c4b5cc044cae5efcc7c29dec06" args="" -->SANITIZER_PATCH_INVALID_SYNCHRONIZATION</em>&nbsp;</td><td>
An invalid synchronization operation was performed. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g9d63f4e3663fc4ce4558668afc151a39"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerAddPatches" ref="g9d63f4e3663fc4ce4558668afc151a39" args="(const void *image, CUcontext ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerAddPatches           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUcontext&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: an API user must serialize access to sanitizerAddPatchesFromFile, sanitizerAddPatches, sanitizerPatchInstructions, and sanitizerPatchModule. For example if sanitizerAddPatches(image) and sanitizerPatchInstruction(*, *, cbName) are called concurrently and cbName is intended to be found in the loaded image, the results are undefined.<p>
The patches loaded are only valid for the specified CUDA context.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to module data to load. This API supports the same module formats as the cuModuleLoadData and cuModuleLoadFatBinary functions from the CUDA driver API. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>CUDA context in which to load the patches. If ctx is NULL, the current context will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_NOT_INITIALIZED</em>&nbsp;</td><td>if unable to initialize the sanitizer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>image</code> does not point to a valid CUDA module. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g04ea679ab0708224d366c48e651e40ef"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerAddPatchesFromFile" ref="g04ea679ab0708224d366c48e651e40ef" args="(const char *filename, CUcontext ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerAddPatchesFromFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUcontext&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: an API user must serialize access to sanitizerAddPatchesFromFile, sanitizerAddPatches, sanitizerPatchInstructions, and sanitizerPatchModule. For example if sanitizerAddPatchesFromFile(filename) and sanitizerPatchInstruction(*, *, cbName) are called concurrently and cbName is intended to be found in the loaded module, the results are undefined.<p>
The patches loaded are only valid for the specified CUDA context.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Path to the module file. This API supports the same module formats as the cuModuleLoad function from the CUDA driver API. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>CUDA context in which to load the patches. If ctx is NULL, the current context will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_NOT_INITIALIZED</em>&nbsp;</td><td>if unable to initialize the sanitizer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>filename</code> is not a path to a valid CUDA module. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8a243dfc09dc2f676114409039a3e80d"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerGetCallbackPcAndSize" ref="g8a243dfc09dc2f676114409039a3e80d" args="(CUcontext ctx, const char *deviceCallbackName, uint64_t *pc, uint64_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerGetCallbackPcAndSize           </td>
          <td>(</td>
          <td class="paramtype">CUcontext&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>deviceCallbackName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>CUDA context in which the patches were loaded. If ctx is NULL, the current context will be used. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>deviceCallbackName</em>&nbsp;</td><td>device function callback name </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pc</em>&nbsp;</td><td>Callback PC returned </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Callback size returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>deviceCallbackName</code> function cannot be located, if pc is NULL or if size is NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g505e9ee66db67d02d15c47b874859545"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerGetFunctionPcAndSize" ref="g505e9ee66db67d02d15c47b874859545" args="(CUmodule module, const char *functionName, uint64_t *pc, uint64_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerGetFunctionPcAndSize           </td>
          <td>(</td>
          <td class="paramtype">CUmodule&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>module</em>&nbsp;</td><td>CUDA module containing the function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>deviceCallbackName</em>&nbsp;</td><td>CUDA function name </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pc</em>&nbsp;</td><td>Function start program counter (PC) returned </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Function size in bytes returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>functionName</code> function cannot be located, if pc is NULL or if size is NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4047e8742dc65935c2ab45d19a53b850"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerPatchInstructions" ref="g4047e8742dc65935c2ab45d19a53b850" args="(const Sanitizer_InstructionId instructionId, CUmodule module, const char *deviceCallbackName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerPatchInstructions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SANITIZER__PATCHING__API.html#g25af2e64f4c5e2a4e012edb4bb991dcf">Sanitizer_InstructionId</a>&nbsp;</td>
          <td class="paramname"> <em>instructionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUmodule&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>deviceCallbackName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark that all instrumentation points matching instructionId are to be patched in order to call the device function identified by deviceCallbackName. It is up to the API client to ensure that this device callback exists and match the correct callback format for this instrumentation point. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: an API user must serialize access to sanitizerAddPatchesFromFile, sanitizerAddPatches, sanitizerPatchInstructions, and sanitizerPatchModule. For example if sanitizerAddPatches(fileName) and sanitizerPatchInstruction(*, *, cbName) are called concurrently and cbName is intended to be found in the loaded module, the results are undefined.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instructionId</em>&nbsp;</td><td>Instrumentation point for which to insert patches </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>CUDA module to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviceCallbackName</em>&nbsp;</td><td>Name of the device function callback that the inserted patch will call at the instrumented points. This function is expected to be found in code previously loaded by sanitizerAddPatchesFromFile or sanitizerAddPatches.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_NOT_INITIALIZED</em>&nbsp;</td><td>if unable to initialize the sanitizer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>module</code> is not a CUDA module or if <code>deviceCallbackName</code> function cannot be located. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2e7500a0e365b2ddf6c273c87a34b22d"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerPatchModule" ref="g2e7500a0e365b2ddf6c273c87a34b22d" args="(CUmodule module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerPatchModule           </td>
          <td>(</td>
          <td class="paramtype">CUmodule&nbsp;</td>
          <td class="paramname"> <em>module</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the instrumentation of a CUDA module based on previous calls to sanitizerPatchInstructions. This function also specifies the device memory buffer to be passed in as userdata to all callback functions. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: an API user must serialize access to sanitizerAddPatchesFromFile, sanitizerAddPatches, sanitizerPatchInstructions, and sanitizerPatchModule. For example if sanitizerPatchModule(mod, *) and sanitizerPatchInstruction(*, mod, *) are called concurrently, the results are undefined.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>CUDA module to instrument</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_ERROR_INVALID_PARAMETER</em>&nbsp;</td><td>if <code>module</code> is not a CUDA module </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g55712541951d15f51e8c294382f91be0"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerSetCallbackData" ref="g55712541951d15f51e8c294382f91be0" args="(CUfunction kernel, const void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerSetCallbackData           </td>
          <td>(</td>
          <td class="paramtype">CUfunction&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark all subsequent launches of <code>kernel</code> to use <code>userdata</code> pointer as the device memory buffer to pass in to callback functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>CUDA function to link to user data. Callbacks in subsequent launches on this kernel will use <code>userdata</code> as callback data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userdata</em>&nbsp;</td><td>Device memory buffer. This data will be passed to callback functions via the <code>userdata</code> parameter.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g5ac4eb8e7b484ac3e70c459413791b22"></a><!-- doxytag: member="sanitizer_patching.h::sanitizerUnpatchModule" ref="g5ac4eb8e7b484ac3e70c459413791b22" args="(CUmodule module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerUnpatchModule           </td>
          <td>(</td>
          <td class="paramtype">CUmodule&nbsp;</td>
          <td class="paramname"> <em>module</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove any instrumentation of a CUDA module performed by previous calls to sanitizerPatchModule. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: an API user must serialize access to sanitizerPatchModule and sanitizerUnpatchModule on the same module. For example, if sanitizerPatchModule(mod) and sanitizerUnpatchModule(mod) are called concurrently, the results are undefined.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>CUDA module on which to remove instrumentation</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SANITIZER_SUCCESS</em>&nbsp;</td><td>on success </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jul 22 23:03:39 2020 for SanitizerApi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
